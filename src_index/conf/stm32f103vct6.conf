#take a look on 'HY-MiniSTM32V 2011.1.18/GPIO/USER/main.c'
#config file bleeding edge version
[base]
includes = stm32f10x.h stdbool.h
header = /* This code is generated by ladder2c */
defines = #define SYS_CLK 24000000 , #define DELAY_TIM_FREQUENCY 1000000
variables = bool M0=false;bool M1=false;bool M2=false;bool M3=false;bool M4=false;bool M5=false;bool M6=false;bool M7=false;bool M8=false;bool M9=false;bool M10=false;bool edge[10]={false};bool timer[10]={false};
#solve dynamic hazard issue and overloading
#snipped from http://www.elektroda.pl/rtvforum/topic1961226.html
functions = /* You can add some custom functions here */
io = void init_gpio(){GPIO_InitTypeDef GPIO_InitStructure;RCC_Conf();NVIC_Conf();RCC_APB2PeriphCloclCmd(RCC_APB2Periph_GPIOB, ENABLE);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOB,&GPIO_InitStructure);GPIO_ResetBits(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9);RCC_APB2PeriphCloclCmd(RCC_APB2Periph_GPIOA, ENABLE);GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOA, &GPIO_InitStructure);}
delay = void delay_init(){RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);TIM_TimeBaseStructure.TIM_ClockDivision = 0;TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;TIM_TimeBaseStructure.TIM_Period = UINT16_MAX;TIM_TimeBaseStructure.TIM_Prescaler=(SYS_CLK/DELAY_TIM_FREQUENCY) - 1;TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);TIM_Cmd(TIM4, ENABLE);}
timer = void setTimer(int Timer, int delay){/*This method uses delay and magic */} 
#bool checkCounter(int actual, int max, bool target) { return actual < max && target; }
edge = bool checkEdge(int Port,int Pin,int e,bool type){if(!edge[e] && GPIO_ReadInputDataBit(Port,Pin)==Bit_SET){if(type){edge[e]=true;}else{edge[e]=false;}}elseif(edge[e] && !(GPIO_ReadInputDataBit(Port, Pin)==Bit_SET){if(type){edge[e]=false;}else{edge[e]=true;}}return edge[e];}
[elements_input]
T0 = getTimer(Timer_0)
T1 = getTimer(Timer_1)
#connectors
X0 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == Bit_SET
X1 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1) == Bit_SET
X2 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_2) == Bit_SET
X3 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_3) == Bit_SET
X4 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_4) == Bit_SET
X5 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5) == Bit_SET
X6 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6) == Bit_SET
X7 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_7) == Bit_SET
X8 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_8) == Bit_SET
X9 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9) == Bit_SET

Y0 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_0) == Bit_SET
Y1 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_1) == Bit_SET
Y2 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_2) == Bit_SET
Y3 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_3) == Bit_SET
Y4 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_4) == Bit_SET
Y5 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_5) == Bit_SET
Y6 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_6) == Bit_SET
Y7 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_7) == Bit_SET
Y8 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_8) == Bit_SET
Y9 = GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_9) == Bit_SET

T0 = timer[0]
T1 = timer[1]
T2 = timer[2]
T3 = timer[3]
T4 = timer[4]
T5 = timer[5]
T6 = timer[6]
T7 = timer[7]
T8 = timer[8]
T9 = timer[9]

M0 = M0
M1 = M1
M2 = M2
M3 = M3
M4 = M4
M5 = M5
M6 = M6
M7 = M7
M8 = M8
M9 = M9
M10 = M10

[elements_output]
#flag
M0 = M0
M1 = M1
M2 = M2
M3 = M3
M4 = M4
M5 = M5
M6 = M6
M7 = M7
M8 = M8
M9 = M9
M10 = M10 
#coils
Y0_SET = GPIO_SetBits(GPIOB, GPIO_Pin_0)
Y1_SET = GPIO_SetBits(GPIOB, GPIO_Pin_1)
Y2_SET = GPIO_SetBits(GPIOB, GPIO_Pin_2)
Y3_SET = GPIO_SetBits(GPIOB, GPIO_Pin_3)
Y4_SET = GPIO_SetBits(GPIOB, GPIO_Pin_4)
Y5_SET = GPIO_SetBits(GPIOB, GPIO_Pin_5)
Y6_SET = GPIO_SetBits(GPIOB, GPIO_Pin_6)
Y7_SET = GPIO_SetBits(GPIOB, GPIO_Pin_7)
Y8_SET = GPIO_SetBits(GPIOB, GPIO_Pin_8)
Y9_SET = GPIO_SetBits(GPIOB, GPIO_Pin_9)

Y0_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_0)
Y1_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_1)
Y2_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_2)
Y3_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_3)
Y4_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_4)
Y5_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_5)
Y6_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_6)
Y7_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_7)
Y8_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_8)
Y9_RESET = GPIO_ResetBits(GPIOB, GPIO_Pin_9)
